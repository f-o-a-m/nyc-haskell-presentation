---

# Querying Data

---

## Haxl Interlude

<center>
<img src="images/free-dsl.png" height="450" width="350">
</center>

---

## What is Haxl?

- Originally developed at Facebook, led by Simon Marlow
- Kind of like a scheduler for monadic computation
  - input "sequential", IO bound, monadic computation
  - will optimally<sup>1</sup> rewrite to parallalelize
  - sophisticated caching
- Really great for time indexed databases where you really don't want to do more work than you have to.


<sub>[1] Not actually optimal (couldn't be), uses heuristics to avoid slow compile times</sub>
  
---

## Example Computation
Suppose we have these functions:

```haskell
-- | Core logic generated by QuasiQuoter, 
--   queries web3 api.
balanceOf 
  :: MonadWeb3 m
  => BlockNumber 
  -> Address 
  -> m (UIntN 256)
...
  
-- | Uses our stored history of all token transfers.
getTraders
  :: MonadPg m
  => BlockNumber
  -> Address
  -> m [Address]
...

```

---

## Example Computation (*continued*)

Let **Neighbor** be a relations with **Neighbor(A,B)** if address A has traded with address B, where B currently has nonzero token balance.

```haskell
-- | Gets the 10 Neighbors with the highest token 
--   balances
getRichestNeighbors
  :: ( MonadWeb3 m
     , MonadPg m
     )
  => BlockNumber
  -> Address
  -> m [(Address, UIntN 256)]
getRichestNeighbors userAddress = do
  traders <- getTraders userAddress
  pairs <- forM traders $ \trader -> do
    bal <- balanceOf bn trader
    pure (trader, bal)
  let pairs' = filter ((> 0) . snd) pairs
  pure . take 10 . sortOn (snd . Down) $ pairs'
```

---

## Example Computation (*continued*)

Introduce another parameter `k` with **NeighborK(A, B, k)** if
there exists A<sub>1</sub> ..., A<sub>i-1</sub> with `i <= k` and **Neighbor(A, A<sub>1</sub>)** ... 
**Neighbor(A<sub>i-1</sub>, B)**. 

---

## Example Computation: Naive Approach

```haskell
getRichestNeighborsK
  :: (MonadWeb3 m, MonadPg m)
  => BlockNumber
  -> Int
  -> Address
  -> m [(Address, UIntN 256)]
getRichestNeighborsK bn k userAddress = do
  neighbors <- go bn k userAddress
  pairs <- forM neighbors $ \n -> do
    bal <- balanceOf bn n
    pure (n, bal)
  pure . take 10 . sortOn (snd . Down) $ pairs 
  where
    go _ 0 _ = pure []
    go bn k userAddress = do
      traders <- getTraders userAddress
      ns <- filterM (fmap (> 0) . balanceOf bn) traders
      concat <$> mapM (go bn (k-1)) ns
```

---

## Example Computation: Problems
- calls `balanceOf` *at least* twice for each address.
- `getTraders` is possibly called multiple times per address.
- any time we used `mapM` (equivalently `forM`), we could be concurrently running each operation.

---

## Bad Solutions
- Run computation in `State` monad holding `MVar` with maps 
  - `traders :: Map Address [Address]`
  - `balances :: Map Address (UIntN 256)` 
- Use combination of `par` strategies and `async`/`wait`.

Building custom concurrency like this is tedious, fragile, and not always composible.

---

## Good Solutions
- Don't do anything at all.
- Let the compiler and libraries work for you.

---

## Haxl Solution

The analogy is:
- `Memory Management` is to `Garbage Collection` as `Concurrency` is to `Haxl`<sup>1</sup>

You might be able to do better with custom concurrency controls, but unlikely. Also, it's probably not the actual problem you're trying to solve at the moment.


<sub>[1] Simon Marlow [StrangeLoop 2017](https://www.youtube.com/watch?v=sT6VJkkhy0o) </sub>


---

## Haxl Scheduler Diagram

Not an AST!
This represents a dependency graph where 
sequential dependencies are marked with `(>>=)` and syncrhonization points with `(<*>)`.

<img src="images/haxl.png" height="450">

---
